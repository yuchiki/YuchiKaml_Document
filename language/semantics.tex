
\subsection{Semantics}

Then we define the semantics of expressions.
We assume that the behaviour of built-in functions are given.
That is, built-in functions is a deterministic.

\subsubsection{Value}
\emph{Values} of expressions are listed as below:

\begin{align*}
    v (\text{value}) &\defeq n \mid b \mid  s \mid  \closure \mid  \builtinFunction\\
    \valuation  (\text{valuation}) &\in \variables \not\to\values \\
    \builtinFunction{} (\text{built-in function})&\in \History \times\values\not\to\values\\
    \closure (\text{closure}) &\defeq (x,e,\valuation{})\\
    h (\text{history}) &\defeq \seq{(f_1, v_1); \cdots; (f_n, v_n)}
\end{align*}



Here $\variables$ is the set of the variables and $\values$ is the set of the values.

\begin{note}
We assume that all the built-in functions are at least function.
It means, all the built-in functions return the same value for the same input, if it does not diverge.
This is not a correct assumption. for example, Random function and Read function may return variable values.
the aim of this assumption is to define the possible implementations of processing systems.
that is, intuitionally, to judge the processing system OK if it works as the same as the expected behaviour under this assumption.
\end{note}

\subsubsection{Small-Step Evaluation}
We have to define the behaviour of evaluation process of expressions clearly.
To this end, we define the \emph{evaluation} process of expression by a big-step semantics shown below.

An \emph{evaluation relation} is a four-term relation of the form $\evalRel{\valuation}{h}{e}{h'}{v}$.

The evaluation rules of YuchiKaml are shown below:

Using this small-step evaluation relation, we define the next big-step evaluation relation.

\infrule[E-Var]
{}
{\evalRel{\valuation}{h}{x}{h}{\valuation(x)}}

\infrule[E-App]
{\evalRel{\valuation}{h}{e_1}{h'}{(x,e_1',\valuation')} \andalso
{\evalRel{\valuation}{h'}{e_2}{h''}{v_2}}}
{\evalRel{\valuation}{h}{e_1\ e_2}{h'''}{v_1'}}

\infrule[E-Not]
{\evalRel{\valuation}{h}{e}{h'}{b}}
{\evalRel{\valuation}{h}{!e}{h'}{\interp{!}b}}

\infrule[E-Mul]
{\evalRel{\valuation}{h}{e_1}{h'}{n_1} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{n_2}}
{\evalRel{\valuation}{h}{e_1 * e_2}{h''}{n_1 \interp{*}n_2}}

\infrule[E-Div]
{\evalRel{\valuation}{h}{e_1}{h'}{n_1} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{n_2}}
{\evalRel{\valuation}{h}{e_1 / e_2}{h''}{n_1 \interp{/}n_2}}


\infrule[E-Plus]
{\evalRel{\valuation}{h}{e_1}{h'}{n_1} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{n_2}}
{\evalRel{\valuation}{h}{e_1 + e_2}{h''}{n_1 \interp{+}n_2}}

\infrule[E-Minus]
{\evalRel{\valuation}{h}{e_1}{h'}{n_1} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{n_2}}
{\evalRel{\valuation}{h}{e_1 - e_2}{h''}{n_1 \interp{-}n_2}}

\infrule[E-Leq]
{\evalRel{\valuation}{h}{e_1}{h'}{n_1} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{n_2}}
{\evalRel{\valuation}{h}{e_1 \leq e_2}{h''}{n_1 \interp{\leq}n_2}}

\infrule[E-Lt]
{\evalRel{\valuation}{h}{e_1}{h'}{n_1} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{n_2}}
{\evalRel{\valuation}{h}{e_1 < e_2}{h''}{n_1 \interp{<}n_2}}

\infrule[E-Geq]
{\evalRel{\valuation}{h}{e_1}{h'}{n_1} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{n_2}}
{\evalRel{\valuation}{h}{e_1 \geq e_2}{h''}{n_1 \interp{\geq}n_2}}

\infrule[E-Gt]
{\evalRel{\valuation}{h}{e_1}{h'}{n_1} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{n_2}}
{\evalRel{\valuation}{h}{e_1 > e_2}{h''}{n_1 \interp{>}n_2}}

\infrule[E-Eq]
{\evalRel{\valuation}{h}{e_1}{h'}{v_1} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{v_2}}
{\evalRel{\valuation}{h}{e_1 = e_2}{h''}{v_1 \interp{=}v_2}}

\infrule[E-Neq]
{\evalRel{\valuation}{h}{e_1}{h'}{v_1} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{v_2}}
{\evalRel{\valuation}{h}{e_1 \not= e_2}{h''}{v_1 \interp{\not=}v_2}}

\infrule[E-And]
{\evalRel{\valuation}{h}{e_1}{h'}{b_1} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{b_2}}
{\evalRel{\valuation}{h}{e_1 \logAnd{} e_2}{h''}{v_1 \interp{\logAnd}v_2}}

\infrule[E-Or]
{\evalRel{\valuation}{h}{e_1}{h'}{b_1} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{b_2}}
{\evalRel{\valuation}{h}{e_1 \logOr{} e_2}{h''}{v_1 \interp{\logOr} v_2}}

\infrule[E-If-True]
{\evalRel{\valuation}{h}{e_1}{h'}{\trueToken} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{v_2}}
{\evalRel{\valuation}{h}{\ifStructure{e_1}{e_2}{e_3}}{h''}{v_2}}

\infrule[E-If-False]
{\evalRel{\valuation}{h}{e_1}{h'}{\falseToken} \andalso
\evalRel{\valuation}{h'}{e_3}{h''}{v_3}}
{\evalRel{\valuation}{h}{\ifStructure{e_1}{e_2}{e_3}}{h''}{v_3}}

\infrule[E-Let]
{
    \evalRel{\valuation}{h}{e_1}{h'}{v_1} \andalso
    \evalRel{\valuation\cup\set{x\mapsto v_1}}{h'}{e_2}{h''}{v_2}
}{
    \evalRel{\valuation}{h}{\letStructure{x}{e_1}{e_2}}{h''}{v_2}
}

\infrule[E-LetRec]
{\evalRel{\mu X. \valuation\cup\set{f \mapsto (x, e_1, X)}}{h}{e_2}{h'}{v_2}}
{\evalRel{\valuation}{h}{\letRecStructure{f}{x}{e_1}{e_2}}{h'}{v_2}}

\infrule[E-AppBuiltIn]
{\evalRel{\valuation}{h}{e_1}{h'}{\builtinFunction} \andalso
\evalRel{\valuation}{h'}{e_2}{h''}{v_2}}
{\evalRel{\valuation}{h}{e_1\ e_2}{\seq{h'', (\builtinFunction, v_2)}}{(\builtinFunction h'' v_2)}}

\infrule[E-Abs]
{}
{\evalRel{\valuation}{h}{\abs{x}{e}}{h}{(x,e,\valuation{})}}
