\usepackage{amsmath,amssymb}

\newcommand{\cs}{C\#}
\newcommand\bnf[1]{\langle\text{#1}\rangle}
\DeclareMathOperator\defeq{:\!:=}

%generic definition
\newcommand\todo[1]{\textbf{\textcolor{red}{TODO: #1}}}
\newcommand\set[1]{\left\{#1\right\}}
\newcommand\setc[2]{\left\{#1 \mid #2\right\}}
\newcommand\seq[1]{\left\langle #1 \right\rangle}
\newcommand\interp[1]{\,[\![#1]\!]\,}

%syntactic tokens

\DeclareMathOperator\binOp{\text{op}}
\DeclareMathOperator\letToken{\text{let}}
\DeclareMathOperator\recToken{\text{rec}}
\DeclareMathOperator\inToken{\text{in}}
\DeclareMathOperator\ifToken{\text{if}}
\DeclareMathOperator\thenToken{\text{then}}
\DeclareMathOperator\elseToken{\text{else}}
\DeclareMathOperator\trueToken{\text{true}}
\DeclareMathOperator\falseToken{\text{false}}
\DeclareMathOperator\logAnd{\&\!\!\!\&}
\DeclareMathOperator\logOr{\,|\!\!\!|\,}
\DeclareMathOperator\logNot{!}
\DeclareMathOperator\opCol{;}
\newcommand\abs[2]{\lambda #1.\ #2}

%structures
\newcommand\ifStructure[3]{\ifToken #1 \thenToken #2 \elseToken #3}
\newcommand\letStructure[3]{\letToken #1 = #2 \inToken #3}
\newcommand\letRecStructure[4]{\letToken \recToken #1\ #2 = #3 \inToken #4}


%semantic tokens
\DeclareMathOperator\VInt{\text{VInt}}
\DeclareMathOperator\VBool{\text{VBool}}
\DeclareMathOperator\VString{\text{VString}}
\DeclareMathOperator\VClosure{\text{VClos}}
\DeclareMathOperator\VBuiltInClosure{\text{VBClos}}

%symbolLetters
\newcommand\valuation{\rho}
\newcommand\builtinFunction{f_b}
\newcommand\closure{\text{cl}}
\newcommand\variables{\text{Var}}
\newcommand\values{\text{Val}}
\newcommand\History{\text{His}}

%operators
%\DeclareMathOperator\pipe{\triangleright}
\newcommand\composition{>\!\!>}

%type judgment
\newcommand\hasType[2]{|- #1 : #2}

\newcommand\evalRel[5]{#1 \vdash  #2; #3 \longrightarrow #4; #5 }
